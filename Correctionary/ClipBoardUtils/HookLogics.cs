using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using CommonObjects;
using System.Windows.Input;
using System.Diagnostics;


namespace HookUtils
{
   
    //We need to inherit from form in order to be added to the clip board chain

    public class HookLogics:Form
    {
        #region Data Members
        /// <summary>
        /// Occurs when a hot key pressed.
        /// </summary>
        public event EventHandler<HotkeyPressedArgs> onHotkeyPressed;

        /// <summary>
        /// Occurs when got highlighted text in active window.
        /// </summary>
        public event EventHandler<ClipBoardDataArgs> onGotHighlightedText;

        /// <summary>
        /// Occurs when failes registrating hot key.
        /// </summary>
        public event EventHandler<ErrorRegistratingHotKeyArgs> onFailedRegistratingHotKey;

        /// <summary>
        /// Hold the information about which hot key (value) is assigned to which action (key).
        /// </summary>
        private Dictionary<HotkeysActions, HotkeyPackage> dicHotkey;
        /// <summary>
        /// Gets the dictionary that hold the information, which key is the hot key for which action
        /// </summary>
        public Dictionary<HotkeysActions, HotkeyPackage> DicHotkey
        {
            get { return dicHotkey; }

        }

        /// <summary>
        /// Sent to the first window in the clipboard viewer chain when the content of the clipboard changes 
        /// (defined in winuser.h). 
        /// </summary>
        const int WM_DRAWCLIPBOARD = 0x308;
        /// <summary>
        /// Sent to the first window in the clipboard viewer chain when a window is being removed from the chain.
        /// (defined in winuser.h)
        /// </summary>
        const int WM_CHANGECBCHAIN = 0x030D;

        /// <summary>
        /// Posted when the user presses a hot key registered by the RegisterHotkey function. 
        /// The message is placed at the top of the message queue associated with the thread that registered the hot key.
        /// </summary>
        const int WM_HOTKEY = 0x0312;

        /// <summary>
        /// Indicates if we have virtually pressed on CTRL C and waiting for the clip board data to arrive
        /// </summary>
        private bool _isWaitingForClipBoardData;

        /// <summary>
        /// When we set the clipboard some data was removed. in order to restore it later, we keep it here.
        /// </summary>
        private ClipBoardDataObject _overridenClipBoardData;
        /// <summary>
        /// A pointer to the next window on the clipboard chain
        /// </summary>
        IntPtr _ptrNextClipboardViewerHandle;
        //TODO:Check if all of its functions can be static
        HookFunctions _actHook; 
        #endregion

        /// <summary>
        /// Initializes a new instance of the <see cref="HookLogics"/> class.
        /// </summary>
        public HookLogics()
        {
            //getting default hot keys, and registering them.
            //TODO: Savehot keys to file
            this.dicHotkey = HookLogics.GetDefaultHotkeys();
            this.registerHotkeys(this.dicHotkey);
            //assigning this window handle to the clipboard chain. the return value is the next handle in chain
            this._ptrNextClipboardViewerHandle = (IntPtr)HookLogics.SetClipboardViewer((int)this.Handle);

            _actHook = new HookFunctions(); // crate an instance with global hooks
            _actHook.Start(true, true);

            // register the events to the Hook class.b
            _actHook.KeyDown += new KeyEventHandler(this.KeyDownHandler);
            _actHook.OnMouseActivity += new MouseEventHandler(this.MouseMovedHandler);
        }


        #region Windows API functions
        [DllImport("User32.dll")]
        protected static extern int SetClipboardViewer(int hWndNewViewer);

        [DllImport("User32.dll", CharSet = CharSet.Auto)]
        public static extern bool ChangeClipboardChain(IntPtr hWndRemove, IntPtr hWndNewNext);

        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        public static extern int SendMessage(IntPtr hwnd, int wMsg, IntPtr wParam, IntPtr lParam);
        /// <summary>
        /// Defines a system-wide hot key.
        /// </summary>
        /// <param name="hWnd">A handle to the window that will receive 
        /// WM_HOTKEY messages generated by the hot key. If this parameter is NULL, WM_HOTKEY messages are posted 
        /// to the message queue of the calling thread and must be processed in the message loop.</param>
        /// <param name="id">The identifier of the hot key. If the hWnd parameter is NULL, 
        /// then the hot key is associated with the current thread rather than with a particular window.
        /// If a hot key already exists with the same hWnd and id parameters, see Remarks for the action taken.</param>
        /// <param name="fsModifiers">The keys that must be pressed in combination 
        /// with the key specified by the uVirtKey parameter in order to generate the WM_HOTKEY message. 
        /// The fsModifiers parameter can be a combination of the values in System.ConsoleModifiers.</param>
        /// <param name="vlc">The virtual-key code of the hot key. this corespond with System.Windows.Forms.Keys Enum.</param>
        /// <returns>If the function succeeds, the return value is nonzero.
        ///If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern int RegisterHotKey(IntPtr hWnd, int id, int fsModifiers, int vlc);


        /// <summary>
        /// Frees a hot key previously registered by the calling thread.
        /// </summary>
        /// <param name="hWnd">A handle to the window associated with the hot key to be freed. This parameter should be NULL if the hot key is not associated with a window.</param>
        /// <param name="id">The identifier of the hot key to be freed..</param>
        /// <returns>If the function succeeds, the return value is nonzero.
        ///If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern int UnregisterHotKey(IntPtr hWnd, int id);

        #endregion

        /// <summary>
        /// Gets the clip board data object. value will be returned in the<see cref="onGotHighlightedText"/> event.
        /// </summary>        
        public void GetHighlightedText()
        {
            //Storing the clipboard data, so later on we can restore it 
            ClipBoardDataObject objectData = GetClipBoardData();
            this._overridenClipBoardData = objectData;
            //Copying highlighted text
            this._isWaitingForClipBoardData = true;
            HookFunctions.VirtualPressCtrlC();

        }

       
        /// <summary>
        /// Registers a hot key.
        /// </summary>
        /// <param name="action">The action to register the action to.</param>
        /// <param name="modifier">The modifier. this should be consistent with ConsoleModifiers (0 for none) .</param>
        /// <param name="key">The key.</param>
        /// <returns></returns>
        public bool RegisterHotkey(HotkeysActions action, ModifierKeys modifier, Keys key)
        {
            //If we already have a hot key, we want to unregister it
            bool isUnregisterSuccess = this.UnRegisterHotkey(action);
            //making sure that we are not double registrating due to previous instances of program
            int result = HookLogics.UnregisterHotKey(this.Handle, (int)action);
            //registering new value (we are action using enum int as ID)
            result = HookLogics.RegisterHotKey(this.Handle, (int)action, (int)modifier, (int)key);
            bool success = result != 0;
            if (success)
            {
                //updating Hotkeys
                HotkeyPackage package = new HotkeyPackage(modifier, key);
                this.dicHotkey[action] = package;

            }
            else
            {
                int errorCode = Marshal.GetLastWin32Error();
                this.TriggerOnFailedToRegisterHotKey(new HotkeyPackage(modifier,key), errorCode);
            }

            return success;

        }

       

        
        /// <summary>
        /// Unregisters a hot key.
        /// </summary>
        /// <param name="action">The action to unregister it's hot key.</param>
        /// <returns>true upon success; false otherwise.
        /// if the hot key was never asigned in the first place, false will be returned</returns>
        public bool UnRegisterHotkey(HotkeysActions action)
        {
            //a non 0 value would be success
            int result = 1;          
            
            Keys OldHotkey = this.dicHotkey[action].Hotkey;
            if (OldHotkey != Keys.None)
            {
                //(we are using enums int as ID)
                int registrationId = (int)action;
                result = HookLogics.UnregisterHotKey(this.Handle, registrationId);
            }

            //updating Hotkeys
            HotkeyPackage package = new HotkeyPackage(System.Windows.Input.ModifierKeys.None, Keys.None);
            this.dicHotkey[action] = package;

            return result != 0;

        }

        /// <summary>
        /// Gets the hot key action by keys.
        /// </summary>
        /// <param name="modifierKeys">The modifier keys.</param>
        /// <param name="keys">The keys.</param>
        /// <returns></returns>
        public HotkeysActions GetActionByKeys(ModifierKeys modifierKey, Keys key)
        {
            HotkeysActions action = HotkeysActions.None;
            foreach (KeyValuePair<HotkeysActions, HotkeyPackage> pair in this.dicHotkey)
            {
                if (pair.Value.Modifier == modifierKey && pair.Value.Hotkey == key)
                {
                    action = pair.Key;
                    break;
                }
            }

            return action;
        }
        /// <summary>
        /// handles messages to the window
        /// </summary>
        /// <param name="message">The message recived.</param>
        protected override void WndProc(ref Message message)
        {
            bool sendMessageToNextInChain = true;
            switch (message.Msg)
            {
                //Clipboard content changed
                case WM_DRAWCLIPBOARD:
                    {
                        //if this is true, than we have changed the clipboard data,
                        //and we want to know what it is now, and set back users clip board
                        if (this._isWaitingForClipBoardData)
                        {
                            //we don't want to enter here again
                            this._isWaitingForClipBoardData = false;
                            this.HandleHighlightedTextIsReady();
                        }
                    }
                    break;
                //In case of change in clip board viewer chain, we want to know who is next in line
                case WM_CHANGECBCHAIN:
                    {
                        if (message.WParam == this._ptrNextClipboardViewerHandle)
                        {
                            this._ptrNextClipboardViewerHandle = message.LParam;
                            //not sure why not sending message, worth while checking some day...
                            sendMessageToNextInChain = false;
                        }
                    }

                    break;
                //A hot key was pressed
                case WM_HOTKEY:
                    //The low Word of message.LParam holds the key
                    Keys key = (Keys)(((int)message.LParam >> 16) & 0xFFFF);
                    //The high Word of message.LParam holds the modifier key
                    ModifierKeys modifier = (ModifierKeys)((int)message.LParam & 0xFFFF);
                    this.TriggerOnHotkeyPressed(modifier, key);
                    break;
                default:
                    base.WndProc(ref message);
                    break;
            }

            if (sendMessageToNextInChain)
            {
                //Dont break the windows clipboard chain...
                HookLogics.SendMessage(this._ptrNextClipboardViewerHandle, message.Msg, message.WParam, message.LParam);
            }

        }

        /// <summary>
        /// Registers the hot keys.
        /// </summary>
        /// <param name="dicKeys">The dictionary that contains key to register keys.</param>
        private void registerHotkeys(Dictionary<HotkeysActions, HotkeyPackage> dicKeys)
        {
            for (int i = 0; i < dicKeys.Keys.Count; i++)
            {
                HotkeysActions action = dicKeys.Keys.ElementAt<HotkeysActions>(i);
                HotkeyPackage package = dicKeys[action];
                ModifierKeys modifier = package.Modifier;
                Keys key = package.Hotkey;
                if (key != Keys.None)
                {

                    this.RegisterHotkey(action, modifier, key);
                }
            }
        }
        /// <summary>
        /// Handles highlighted text is ready.
        /// </summary>
        private void HandleHighlightedTextIsReady()
        {
            //getting data currently in clipboard
            ClipBoardDataObject clipBoardDataObject = this.GetClipBoardData();
            
            Debug.Assert(clipBoardDataObject.RawData != null);

            //if it is not success, we have lost user's clipboard data
            bool success = this.SetClipBoardData(this._overridenClipBoardData);
            if (!success)
            {
                //TODO: Add log
            }
            this.TriggerOnGotHighlightedText(clipBoardDataObject);

        }

        
        /// <summary>
        /// Gets the current clip board data.
        /// </summary>
        /// <returns></returns>
        private ClipBoardDataObject GetClipBoardData()
        {
            bool errorOccured = false; ;
            string errorMessage = String.Empty;           
           
            //The data that will hold info from clipboard
            IDataObject dataObj = null;
            try
            {

                //attempting to get data
                dataObj = Clipboard.GetDataObject();
              
            }
            catch (System.Runtime.InteropServices.ExternalException ex)
            {

                errorOccured = true;
                errorMessage = ex.Message;
            }
            catch (System.Threading.ThreadStateException ex)
            {
                errorOccured = true;
                errorMessage = ex.Message;
            }

            ClipBoardDataObject objectData = new ClipBoardDataObject(dataObj, errorOccured, errorMessage);
            return objectData;
        }

        /// <summary>
        /// Gets the current clip board data.
        /// </summary>
        /// <param name="iDataObj">The data object to set.</param>
        /// <returns>true upon sucess; false otherwise</returns>
        private bool SetClipBoardData(ClipBoardDataObject clipBoardDataObject)
        {
            bool success = true;

            try
            {
                //attempting to set data
                //Clipboard.SetDataObject(clipBoardDataObject, true, 2, 100);
                Clipboard.SetDataObject(clipBoardDataObject.Text);
            }
            catch (System.Runtime.InteropServices.ExternalException)
            {
                //TODO: Add log.
                success = false;
            }
            catch (System.Threading.ThreadStateException)
            {
                //TODO: Add log.
                success = false;
            }
            return success;
        }

        /// <summary>
        /// Keys down handler.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Forms.KeyEventArgs"/> instance containing the event data.</param>
        private void KeyDownHandler(object sender, KeyEventArgs e)
        {
            if (e.KeyData == Keys.LControlKey)
            {
                //Methodology changed. Nothing to do here.
            }
        }
        /// <summary>
        /// Mouses the moved handler.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Forms.MouseEventArgs"/> instance containing the event data.</param>
        private void MouseMovedHandler(object sender, MouseEventArgs e)
        {
            if ((e.Clicks > 0) && (e.Button == MouseButtons.Left))
            {
                //Methodology changed. Nothing to do here.
            }
        }
        /// <summary>
        /// Gets the default hot keys dictionary.
        /// </summary>
        /// <returns></returns>
        private static Dictionary<HotkeysActions, HotkeyPackage> GetDefaultHotkeys()
        {
            //the dictionary To return
            Dictionary<HotkeysActions, HotkeyPackage> retDic = new Dictionary<HotkeysActions, HotkeyPackage>();
            //Making sure there will be no values with no key
            Array arrHotkeys = Enum.GetValues(typeof(HotkeysActions));
            foreach (HotkeysActions currAction in arrHotkeys)
            {
                HotkeyPackage package = new HotkeyPackage(System.Windows.Input.ModifierKeys.None, Keys.None);
                retDic.Add(currAction, package);
            }

            //assigning default.

            retDic[HotkeysActions.ObtainContext] =
                new HotkeyPackage(System.Windows.Input.ModifierKeys.Control, Keys.F5);

            retDic[HotkeysActions.TranslateWord] = 
                new HotkeyPackage(System.Windows.Input.ModifierKeys.Control, Keys.F6);
            
            retDic[HotkeysActions.ReverseTranslate] = 
                new HotkeyPackage(System.Windows.Input.ModifierKeys.Control, Keys.F7);
            
            retDic[HotkeysActions.TranslateParagraph] =
              new HotkeyPackage(System.Windows.Input.ModifierKeys.Control, Keys.F8);

            return retDic;
        }
        /// <summary>
        /// Triggers the on hot key pressed event.
        /// </summary>
        /// <param name="modifier">The modifier.</param>
        /// <param name="key">The key.</param>
        private void TriggerOnHotkeyPressed(ModifierKeys modifier, Keys key)
        {
            if (this.onHotkeyPressed != null)
            {
                HotkeyPressedArgs e = new HotkeyPressedArgs( modifier,  key);
                this.onHotkeyPressed(this, e);
            }
        }
        /// <summary>
        /// Triggers the on Got Highlighted Text event.
        /// </summary>
        /// <param name="modifier">The modifier.</param>
        /// <param name="key">The key.</param>
        private void TriggerOnGotHighlightedText(ClipBoardDataObject clipBoardDataObject)
        {
            if (this.onGotHighlightedText != null)
            {
                ClipBoardDataArgs e = new ClipBoardDataArgs(clipBoardDataObject);
                this.onGotHighlightedText(this, e);
            }
        }

        /// <summary>
        /// Triggers the on failed to register hot key.
        /// </summary>
        /// <param name="hotkeyPackage">The hotkey package.</param>
        /// <param name="errorCode">The error code.</param>        
        private void TriggerOnFailedToRegisterHotKey(HotkeyPackage hotkeyPackage, int errorCode)
        {
            if (this.onFailedRegistratingHotKey != null)
            {
                ErrorRegistratingHotKeyArgs args = new ErrorRegistratingHotKeyArgs(hotkeyPackage, errorCode);
               this.onFailedRegistratingHotKey(this,args);
            }
        }
        /// <summary>
        /// Sets the hot keys.
        /// </summary>
        /// <param name="translationKeys">The translation keys.</param>
        /// <param name="reverseTranslationKeys">The reverse translation keys.</param>
        public void SetHotKeys(HotkeyPackage translationKeys, HotkeyPackage reverseTranslationKeys)
        {
            this.RegisterHotkey(HotkeysActions.TranslateWord, translationKeys.Modifier, translationKeys.Hotkey);
            
            this.RegisterHotkey(HotkeysActions.ReverseTranslate, reverseTranslationKeys.Modifier, reverseTranslationKeys.Hotkey);
        }
    }

   
}
